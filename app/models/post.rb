class Post < ActiveRecord::Base

  HTML_MARKUP = 'html'
  PLAIN_MARKUP = 'plain'
  TEXTILE_MARKUP = 'textile'

  acts_as_taggable

  acts_as_textiled :body

  serialize :extra_content, Hash

  belongs_to :service

  cattr_reader :per_page
  @@per_page = 12

  validates_presence_of :service_id, :service_action, :title, :summary, :published_at
  validates_presence_of :body, :if => :is_article?
  validates_presence_of :identifier, :url, :unless => :is_article?
  
  validates_uniqueness_of :identifier, :scope => :service_id, :unless => :is_article?

  before_validation_on_create :set_published_at_if_article
  before_validation_on_create :set_service_action_if_article

  before_validation :summarize_if_article

  before_create :slugify_if_article
  before_create :add_default_tags_if_article
  before_create :taggify

  named_scope :published, 
    :conditions => ['`posts`.`published` = ?', true]
  named_scope :unpublished, 
    :conditions => ['`posts`.`published` = ?', false]
  named_scope :ordered,
    :order => '`posts`.`published_at` DESC, `posts`.`created_at` DESC'
  named_scope :latest,
    :limit => 5
  named_scope :with_service,
    :include => :service

  # returns true if this post is associated with a BlogService
  def is_article?
    self.service.class == BlogService
  end

  # returns true if there's already a post with the same service_id and
  # identifier, false otherwise.
  def exists?
    return true unless self.new_record?
    unless self.valid?
      if self.errors.on(:identifier) == I18n.t('activerecord.errors.messages.exclusion')
        true
      else
        false
      end
    else
      false
    end
  end

  def summary
    text = read_attribute(:summary)
    return text if self.new_record?
    text == '-' ? nil : text
  end

  def title
    text = read_attribute(:title)
    return text if self.new_record?
    text == '-' ? nil : text
  end

  def context
    previous_post = Post.published.ordered.
      find_by_service_id(
        self.service_id,
        :conditions => ['`posts`.`published_at` >= ? AND `posts`.`id` <> ?', self.published_at, self.id]
      )

    next_post = Post.published.ordered.
      find_by_service_id(
        self.service_id,
        :conditions => ['`posts`.`published_at` <= ? AND `posts`.`id` <> ?', self.published_at, self.id]
      )

    return previous_post, next_post
  end

  # http://deaddeadgood.com/2008/3/11/will_paginate-and-acts_as_taggable_on_steroids
  def self.paged_find_tagged_with(tags, args = {})
    if tags.blank?
      paginate args
    else
      options = find_options_for_find_tagged_with(tags, :match_all => true)
      options.merge!(args)
      # The default count query generated by paginate includes COUNT(DISTINCT Posts.*) which errors, at least on mysql
      # Below we override the default select statement used to perform the count so that it becomes COUNT(DISTINCT Posts.id)
      paginate(options.merge(:count => { :select => options[:select].gsub('*', 'id') }))
    end
  end

  protected

    # before_create
    def slugify_if_article
      if is_article?
        temp_slug = PermalinkFu.escape(self.title)[0..60]
        i = 1
        while Post.find_by_slug_and_service_id(temp_slug, self.service_id) do
          temp_slug << "-#{i}"
          i += 1
        end
        self.slug = temp_slug
      end
    end

    # before_create
    def add_default_tags_if_article
      if is_article?
        self.tag_list.add('posts')
      end
    end

    # before_validation_on_create
    def set_published_at_if_article
      if is_article? && self.published_at.blank?
        self.published_at = Time.current
      end
    end

    # before_validation_on_create
    def set_service_action_if_article
      if is_article?
        self.service_action = Service::SERVICE_ACTION_POST
      end
    end

    # before_validation
    def summarize_if_article
      if is_article?
        self.summary = self.body_plain
      end
    end

    # before_create
    def taggify
      if self.extra_content && 
          self.extra_content['original_tags'] &&
          self.tag_list.empty?
        self.tag_list = self.extra_content['original_tags'].
          map(&:downcase).
          join(', ').
          downcase
      end
    end

end
